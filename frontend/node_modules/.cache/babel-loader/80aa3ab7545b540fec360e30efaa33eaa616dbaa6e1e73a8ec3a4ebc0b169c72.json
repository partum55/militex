{"ast":null,"code":"import api from'./api';import jwt_decode from'jwt-decode';const TOKEN_KEY='token';const REFRESH_TOKEN_KEY='refreshToken';const USER_KEY='user';const AuthService={login:async(username,password)=>{try{const response=await api.post('token/',{username,password});if(response.data.access){localStorage.setItem(TOKEN_KEY,response.data.access);localStorage.setItem(REFRESH_TOKEN_KEY,response.data.refresh);}return response.data;}catch(error){throw error;}},logout:()=>{localStorage.removeItem(TOKEN_KEY);localStorage.removeItem(REFRESH_TOKEN_KEY);localStorage.removeItem(USER_KEY);},register:async userData=>{return api.post('users/',userData);},getCurrentUser:async()=>{try{const response=await api.get('users/me/');localStorage.setItem(USER_KEY,JSON.stringify(response.data));return response.data;}catch(error){throw error;}},updateProfile:async userData=>{try{const response=await api.patch('users/me/',userData);localStorage.setItem(USER_KEY,JSON.stringify(response.data));return response.data;}catch(error){throw error;}},getToken:()=>{return localStorage.getItem(TOKEN_KEY);},getRefreshToken:()=>{return localStorage.getItem(REFRESH_TOKEN_KEY);},isTokenValid:token=>{if(!token)return false;try{const decoded=jwt_decode(token);const currentTime=Date.now()/1000;// Check if token is expired\nreturn decoded.exp>currentTime;}catch(error){return false;}},refreshToken:async()=>{try{const refreshToken=AuthService.getRefreshToken();if(!refreshToken){throw new Error('No refresh token available');}const response=await api.post('token/refresh/',{refresh:refreshToken});if(response.data.access){localStorage.setItem(TOKEN_KEY,response.data.access);return response.data.access;}else{throw new Error('Access token not received');}}catch(error){// Clear tokens on refresh failure\nAuthService.logout();throw error;}},/**\r\n   * Ensures a valid token is available\r\n   * @returns {Promise<string>} Valid access token\r\n   */ensureValidToken:async()=>{const token=AuthService.getToken();if(!token){throw new Error('Not authenticated');}if(!AuthService.isTokenValid(token)){// Token expired, try to refresh\nreturn await AuthService.refreshToken();}return token;},/**\r\n   * Checks if the user is authenticated with a valid token\r\n   * @returns {boolean} Authentication status\r\n   */isAuthenticated:()=>{const token=AuthService.getToken();return!!token&&AuthService.isTokenValid(token);}};export default AuthService;","map":{"version":3,"names":["api","jwt_decode","TOKEN_KEY","REFRESH_TOKEN_KEY","USER_KEY","AuthService","login","username","password","response","post","data","access","localStorage","setItem","refresh","error","logout","removeItem","register","userData","getCurrentUser","get","JSON","stringify","updateProfile","patch","getToken","getItem","getRefreshToken","isTokenValid","token","decoded","currentTime","Date","now","exp","refreshToken","Error","ensureValidToken","isAuthenticated"],"sources":["C:/Users/partu/Desktop/militex/frontend/src/services/auth.service.js"],"sourcesContent":["import api from './api';\r\nimport jwt_decode from 'jwt-decode';\r\n\r\nconst TOKEN_KEY = 'token';\r\nconst REFRESH_TOKEN_KEY = 'refreshToken';\r\nconst USER_KEY = 'user';\r\n\r\nconst AuthService = {\r\n  login: async (username, password) => {\r\n    try {\r\n      const response = await api.post('token/', {\r\n        username,\r\n        password,\r\n      });\r\n\r\n      if (response.data.access) {\r\n        localStorage.setItem(TOKEN_KEY, response.data.access);\r\n        localStorage.setItem(REFRESH_TOKEN_KEY, response.data.refresh);\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  logout: () => {\r\n    localStorage.removeItem(TOKEN_KEY);\r\n    localStorage.removeItem(REFRESH_TOKEN_KEY);\r\n    localStorage.removeItem(USER_KEY);\r\n  },\r\n\r\n  register: async (userData) => {\r\n    return api.post('users/', userData);\r\n  },\r\n\r\n  getCurrentUser: async () => {\r\n    try {\r\n      const response = await api.get('users/me/');\r\n      localStorage.setItem(USER_KEY, JSON.stringify(response.data));\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  updateProfile: async (userData) => {\r\n    try {\r\n      const response = await api.patch('users/me/', userData);\r\n      localStorage.setItem(USER_KEY, JSON.stringify(response.data));\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  getToken: () => {\r\n    return localStorage.getItem(TOKEN_KEY);\r\n  },\r\n\r\n  getRefreshToken: () => {\r\n    return localStorage.getItem(REFRESH_TOKEN_KEY);\r\n  },\r\n\r\n  isTokenValid: (token) => {\r\n    if (!token) return false;\r\n\r\n    try {\r\n      const decoded = jwt_decode(token);\r\n      const currentTime = Date.now() / 1000;\r\n\r\n      // Check if token is expired\r\n      return decoded.exp > currentTime;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  refreshToken: async () => {\r\n    try {\r\n      const refreshToken = AuthService.getRefreshToken();\r\n\r\n      if (!refreshToken) {\r\n        throw new Error('No refresh token available');\r\n      }\r\n\r\n      const response = await api.post('token/refresh/', {\r\n        refresh: refreshToken,\r\n      });\r\n\r\n      if (response.data.access) {\r\n        localStorage.setItem(TOKEN_KEY, response.data.access);\r\n        return response.data.access;\r\n      } else {\r\n        throw new Error('Access token not received');\r\n      }\r\n    } catch (error) {\r\n      // Clear tokens on refresh failure\r\n      AuthService.logout();\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Ensures a valid token is available\r\n   * @returns {Promise<string>} Valid access token\r\n   */\r\n  ensureValidToken: async () => {\r\n    const token = AuthService.getToken();\r\n\r\n    if (!token) {\r\n      throw new Error('Not authenticated');\r\n    }\r\n\r\n    if (!AuthService.isTokenValid(token)) {\r\n      // Token expired, try to refresh\r\n      return await AuthService.refreshToken();\r\n    }\r\n\r\n    return token;\r\n  },\r\n\r\n  /**\r\n   * Checks if the user is authenticated with a valid token\r\n   * @returns {boolean} Authentication status\r\n   */\r\n  isAuthenticated: () => {\r\n    const token = AuthService.getToken();\r\n    return !!token && AuthService.isTokenValid(token);\r\n  }\r\n};\r\n\r\nexport default AuthService;\r\n"],"mappings":"AAAA,MAAO,CAAAA,GAAG,KAAM,OAAO,CACvB,MAAO,CAAAC,UAAU,KAAM,YAAY,CAEnC,KAAM,CAAAC,SAAS,CAAG,OAAO,CACzB,KAAM,CAAAC,iBAAiB,CAAG,cAAc,CACxC,KAAM,CAAAC,QAAQ,CAAG,MAAM,CAEvB,KAAM,CAAAC,WAAW,CAAG,CAClBC,KAAK,CAAE,KAAAA,CAAOC,QAAQ,CAAEC,QAAQ,GAAK,CACnC,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAT,GAAG,CAACU,IAAI,CAAC,QAAQ,CAAE,CACxCH,QAAQ,CACRC,QACF,CAAC,CAAC,CAEF,GAAIC,QAAQ,CAACE,IAAI,CAACC,MAAM,CAAE,CACxBC,YAAY,CAACC,OAAO,CAACZ,SAAS,CAAEO,QAAQ,CAACE,IAAI,CAACC,MAAM,CAAC,CACrDC,YAAY,CAACC,OAAO,CAACX,iBAAiB,CAAEM,QAAQ,CAACE,IAAI,CAACI,OAAO,CAAC,CAChE,CAEA,MAAO,CAAAN,QAAQ,CAACE,IAAI,CACtB,CAAE,MAAOK,KAAK,CAAE,CACd,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAEDC,MAAM,CAAEA,CAAA,GAAM,CACZJ,YAAY,CAACK,UAAU,CAAChB,SAAS,CAAC,CAClCW,YAAY,CAACK,UAAU,CAACf,iBAAiB,CAAC,CAC1CU,YAAY,CAACK,UAAU,CAACd,QAAQ,CAAC,CACnC,CAAC,CAEDe,QAAQ,CAAE,KAAO,CAAAC,QAAQ,EAAK,CAC5B,MAAO,CAAApB,GAAG,CAACU,IAAI,CAAC,QAAQ,CAAEU,QAAQ,CAAC,CACrC,CAAC,CAEDC,cAAc,CAAE,KAAAA,CAAA,GAAY,CAC1B,GAAI,CACF,KAAM,CAAAZ,QAAQ,CAAG,KAAM,CAAAT,GAAG,CAACsB,GAAG,CAAC,WAAW,CAAC,CAC3CT,YAAY,CAACC,OAAO,CAACV,QAAQ,CAAEmB,IAAI,CAACC,SAAS,CAACf,QAAQ,CAACE,IAAI,CAAC,CAAC,CAC7D,MAAO,CAAAF,QAAQ,CAACE,IAAI,CACtB,CAAE,MAAOK,KAAK,CAAE,CACd,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAEDS,aAAa,CAAE,KAAO,CAAAL,QAAQ,EAAK,CACjC,GAAI,CACF,KAAM,CAAAX,QAAQ,CAAG,KAAM,CAAAT,GAAG,CAAC0B,KAAK,CAAC,WAAW,CAAEN,QAAQ,CAAC,CACvDP,YAAY,CAACC,OAAO,CAACV,QAAQ,CAAEmB,IAAI,CAACC,SAAS,CAACf,QAAQ,CAACE,IAAI,CAAC,CAAC,CAC7D,MAAO,CAAAF,QAAQ,CAACE,IAAI,CACtB,CAAE,MAAOK,KAAK,CAAE,CACd,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAEDW,QAAQ,CAAEA,CAAA,GAAM,CACd,MAAO,CAAAd,YAAY,CAACe,OAAO,CAAC1B,SAAS,CAAC,CACxC,CAAC,CAED2B,eAAe,CAAEA,CAAA,GAAM,CACrB,MAAO,CAAAhB,YAAY,CAACe,OAAO,CAACzB,iBAAiB,CAAC,CAChD,CAAC,CAED2B,YAAY,CAAGC,KAAK,EAAK,CACvB,GAAI,CAACA,KAAK,CAAE,MAAO,MAAK,CAExB,GAAI,CACF,KAAM,CAAAC,OAAO,CAAG/B,UAAU,CAAC8B,KAAK,CAAC,CACjC,KAAM,CAAAE,WAAW,CAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAErC;AACA,MAAO,CAAAH,OAAO,CAACI,GAAG,CAAGH,WAAW,CAClC,CAAE,MAAOjB,KAAK,CAAE,CACd,MAAO,MAAK,CACd,CACF,CAAC,CAEDqB,YAAY,CAAE,KAAAA,CAAA,GAAY,CACxB,GAAI,CACF,KAAM,CAAAA,YAAY,CAAGhC,WAAW,CAACwB,eAAe,CAAC,CAAC,CAElD,GAAI,CAACQ,YAAY,CAAE,CACjB,KAAM,IAAI,CAAAC,KAAK,CAAC,4BAA4B,CAAC,CAC/C,CAEA,KAAM,CAAA7B,QAAQ,CAAG,KAAM,CAAAT,GAAG,CAACU,IAAI,CAAC,gBAAgB,CAAE,CAChDK,OAAO,CAAEsB,YACX,CAAC,CAAC,CAEF,GAAI5B,QAAQ,CAACE,IAAI,CAACC,MAAM,CAAE,CACxBC,YAAY,CAACC,OAAO,CAACZ,SAAS,CAAEO,QAAQ,CAACE,IAAI,CAACC,MAAM,CAAC,CACrD,MAAO,CAAAH,QAAQ,CAACE,IAAI,CAACC,MAAM,CAC7B,CAAC,IAAM,CACL,KAAM,IAAI,CAAA0B,KAAK,CAAC,2BAA2B,CAAC,CAC9C,CACF,CAAE,MAAOtB,KAAK,CAAE,CACd;AACAX,WAAW,CAACY,MAAM,CAAC,CAAC,CACpB,KAAM,CAAAD,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA;AACA,KACEuB,gBAAgB,CAAE,KAAAA,CAAA,GAAY,CAC5B,KAAM,CAAAR,KAAK,CAAG1B,WAAW,CAACsB,QAAQ,CAAC,CAAC,CAEpC,GAAI,CAACI,KAAK,CAAE,CACV,KAAM,IAAI,CAAAO,KAAK,CAAC,mBAAmB,CAAC,CACtC,CAEA,GAAI,CAACjC,WAAW,CAACyB,YAAY,CAACC,KAAK,CAAC,CAAE,CACpC;AACA,MAAO,MAAM,CAAA1B,WAAW,CAACgC,YAAY,CAAC,CAAC,CACzC,CAEA,MAAO,CAAAN,KAAK,CACd,CAAC,CAED;AACF;AACA;AACA,KACES,eAAe,CAAEA,CAAA,GAAM,CACrB,KAAM,CAAAT,KAAK,CAAG1B,WAAW,CAACsB,QAAQ,CAAC,CAAC,CACpC,MAAO,CAAC,CAACI,KAAK,EAAI1B,WAAW,CAACyB,YAAY,CAACC,KAAK,CAAC,CACnD,CACF,CAAC,CAED,cAAe,CAAA1B,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}