{"ast":null,"code":"import api from './api';\nimport jwt_decode from 'jwt-decode';\nconst TOKEN_KEY = 'token';\nconst REFRESH_TOKEN_KEY = 'refreshToken';\nconst USER_KEY = 'user';\nconst AuthService = {\n  login: async (username, password) => {\n    try {\n      const response = await api.post('token/', {\n        username,\n        password\n      });\n      if (response.data.access) {\n        localStorage.setItem(TOKEN_KEY, response.data.access);\n        localStorage.setItem(REFRESH_TOKEN_KEY, response.data.refresh);\n      }\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  logout: () => {\n    localStorage.removeItem(TOKEN_KEY);\n    localStorage.removeItem(REFRESH_TOKEN_KEY);\n    localStorage.removeItem(USER_KEY);\n  },\n  register: async userData => {\n    return api.post('users/', userData);\n  },\n  getCurrentUser: async () => {\n    try {\n      const response = await api.get('users/me/');\n      localStorage.setItem(USER_KEY, JSON.stringify(response.data));\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  updateProfile: async userData => {\n    try {\n      const response = await api.patch('users/me/', userData);\n      localStorage.setItem(USER_KEY, JSON.stringify(response.data));\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  },\n  getToken: () => {\n    return localStorage.getItem(TOKEN_KEY);\n  },\n  getRefreshToken: () => {\n    return localStorage.getItem(REFRESH_TOKEN_KEY);\n  },\n  isTokenValid: token => {\n    if (!token) return false;\n    try {\n      const decoded = jwt_decode(token);\n      const currentTime = Date.now() / 1000;\n\n      // Check if token is expired\n      return decoded.exp > currentTime;\n    } catch (error) {\n      return false;\n    }\n  },\n  refreshToken: async () => {\n    try {\n      const refreshToken = AuthService.getRefreshToken();\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n      const response = await api.post('token/refresh/', {\n        refresh: refreshToken\n      });\n      if (response.data.access) {\n        localStorage.setItem(TOKEN_KEY, response.data.access);\n        return response.data.access;\n      } else {\n        throw new Error('Access token not received');\n      }\n    } catch (error) {\n      // Clear tokens on refresh failure\n      AuthService.logout();\n      throw error;\n    }\n  },\n  /**\r\n   * Ensures a valid token is available\r\n   * @returns {Promise<string>} Valid access token\r\n   */\n  ensureValidToken: async () => {\n    const token = AuthService.getToken();\n    if (!token) {\n      throw new Error('Not authenticated');\n    }\n    if (!AuthService.isTokenValid(token)) {\n      // Token expired, try to refresh\n      return await AuthService.refreshToken();\n    }\n    return token;\n  },\n  /**\r\n   * Checks if the user is authenticated with a valid token\r\n   * @returns {boolean} Authentication status\r\n   */\n  isAuthenticated: () => {\n    const token = AuthService.getToken();\n    return !!token && AuthService.isTokenValid(token);\n  }\n};\nexport default AuthService;","map":{"version":3,"names":["api","jwt_decode","TOKEN_KEY","REFRESH_TOKEN_KEY","USER_KEY","AuthService","login","username","password","response","post","data","access","localStorage","setItem","refresh","error","logout","removeItem","register","userData","getCurrentUser","get","JSON","stringify","updateProfile","patch","getToken","getItem","getRefreshToken","isTokenValid","token","decoded","currentTime","Date","now","exp","refreshToken","Error","ensureValidToken","isAuthenticated"],"sources":["C:/Users/partu/Desktop/militex/frontend/src/services/auth.service.js"],"sourcesContent":["import api from './api';\r\nimport jwt_decode from 'jwt-decode';\r\n\r\nconst TOKEN_KEY = 'token';\r\nconst REFRESH_TOKEN_KEY = 'refreshToken';\r\nconst USER_KEY = 'user';\r\n\r\nconst AuthService = {\r\n  login: async (username, password) => {\r\n    try {\r\n      const response = await api.post('token/', {\r\n        username,\r\n        password,\r\n      });\r\n\r\n      if (response.data.access) {\r\n        localStorage.setItem(TOKEN_KEY, response.data.access);\r\n        localStorage.setItem(REFRESH_TOKEN_KEY, response.data.refresh);\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  logout: () => {\r\n    localStorage.removeItem(TOKEN_KEY);\r\n    localStorage.removeItem(REFRESH_TOKEN_KEY);\r\n    localStorage.removeItem(USER_KEY);\r\n  },\r\n\r\n  register: async (userData) => {\r\n    return api.post('users/', userData);\r\n  },\r\n\r\n  getCurrentUser: async () => {\r\n    try {\r\n      const response = await api.get('users/me/');\r\n      localStorage.setItem(USER_KEY, JSON.stringify(response.data));\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  updateProfile: async (userData) => {\r\n    try {\r\n      const response = await api.patch('users/me/', userData);\r\n      localStorage.setItem(USER_KEY, JSON.stringify(response.data));\r\n      return response.data;\r\n    } catch (error) {\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  getToken: () => {\r\n    return localStorage.getItem(TOKEN_KEY);\r\n  },\r\n\r\n  getRefreshToken: () => {\r\n    return localStorage.getItem(REFRESH_TOKEN_KEY);\r\n  },\r\n\r\n  isTokenValid: (token) => {\r\n    if (!token) return false;\r\n\r\n    try {\r\n      const decoded = jwt_decode(token);\r\n      const currentTime = Date.now() / 1000;\r\n\r\n      // Check if token is expired\r\n      return decoded.exp > currentTime;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  refreshToken: async () => {\r\n    try {\r\n      const refreshToken = AuthService.getRefreshToken();\r\n\r\n      if (!refreshToken) {\r\n        throw new Error('No refresh token available');\r\n      }\r\n\r\n      const response = await api.post('token/refresh/', {\r\n        refresh: refreshToken,\r\n      });\r\n\r\n      if (response.data.access) {\r\n        localStorage.setItem(TOKEN_KEY, response.data.access);\r\n        return response.data.access;\r\n      } else {\r\n        throw new Error('Access token not received');\r\n      }\r\n    } catch (error) {\r\n      // Clear tokens on refresh failure\r\n      AuthService.logout();\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Ensures a valid token is available\r\n   * @returns {Promise<string>} Valid access token\r\n   */\r\n  ensureValidToken: async () => {\r\n    const token = AuthService.getToken();\r\n\r\n    if (!token) {\r\n      throw new Error('Not authenticated');\r\n    }\r\n\r\n    if (!AuthService.isTokenValid(token)) {\r\n      // Token expired, try to refresh\r\n      return await AuthService.refreshToken();\r\n    }\r\n\r\n    return token;\r\n  },\r\n\r\n  /**\r\n   * Checks if the user is authenticated with a valid token\r\n   * @returns {boolean} Authentication status\r\n   */\r\n  isAuthenticated: () => {\r\n    const token = AuthService.getToken();\r\n    return !!token && AuthService.isTokenValid(token);\r\n  }\r\n};\r\n\r\nexport default AuthService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}